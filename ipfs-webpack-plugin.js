const path = require('path')
const fs = require('fs')
const IPFS = require('ipfs')

// TODO - doesn't exit properly, ipfs node is keeping process running?
// TODO - get to work in Chrome "Uncaught RangeError: Array buffer allocation failed"

function IPFSWebpackPlugin (options) {
  // TODO allow to inject build-ipfs-node options and loader-ipfs-node options
  // TODO allow disabling the spinner
}

function addFile (pathToAdd, transform) {
  const fullPath = path.resolve(__dirname, pathToAdd)
  return {
    source: function () {
      return fs.readFileSync(fullPath)
    },
    size: function () {
      return fs.statSync(fullPath).size
    }
  }
}

IPFSWebpackPlugin.prototype.assetsLoader = function(){

}

IPFSWebpackPlugin.prototype.apply = function (compiler) {

  
  // Here the compiler beings emitting assets, add our loader + ipfs node
  compiler.plugin('emit', (params, callback) => {
    console.log('HEHOOOOOOO');
    params.assets['loader.js'] = addFile('loader.js')
    params.assets['ipfs.js'] = addFile('ipfs.js')

    params.chunks.forEach(function(chunk) {
      // outputs list of files
      console.log(chunk.files);
     
      // Explore each module within the chunk (built inputs):
    /*  chunk.forEachModule(function(module) {
        // Explore each source file path that was included into the module:
        module.fileDependencies.forEach(function(filepath) {
          // we've learned a lot about the source structure now...
        });
      });
*/
      // Explore each asset filename generated by the chunk:
      chunk.files.forEach(function(filename) {
        // Get the asset source for each file generated by the chunk:
       // console.log(filename);
        var source = params.assets[filename].source();
        
      });
    });


    callback()
  })
  // The compiler is done with all generation, time to modify the loader with the correct hash
  // TODO should handle all assets, currently just one
  compiler.plugin('done', (stats) => {
 
    const { outputOptions } = stats.compilation
    
    
   // const node = new IPFS();

    
   /* 
    node.on('init', () => {
      console.log('====== HERE ======');
      console.log(outputOptions.filename);
      console.log('intializing ipfs');
    })  

    node.files.add()
    node.on('ready', () => {

      node.files.add(fs.readFileSync(fileToAdd)).then((res) => {
        console.log('TEST TEST TEST TEST TEST TEST TEST');
        console.log(res);
      }).catch((err) => {
        console.log(err);
      });

      node.files.add(fs.readFileSync(fileToAdd), (err, res) => {
        if (err) return callback(err);
        console.log(res);
        const { hash, size } = res[0]
        // Replace hash in loader to the one for the asset
        const fileToReplaceIn = path.resolve(outputOptions.path, 'loader.js')
        console.log('replacing asset :');
        console.log(fileToReplaceIn);
        const file = fs.readFileSync(fileToReplaceIn).toString(); // 
        const fileReplaced = file.replace('__replaced_hash__', hash); 
        return fs.writeFileSync(fileToReplaceIn, fileReplaced);
      })
    })
    node.on('error', (err) => {
      throw err
    })
    */
  })
}

module.exports = IPFSWebpackPlugin

